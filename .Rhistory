blogdown::new_site()
.Library
.Library.site
.libPaths()
.libPaths()
R.home()
Sys.getenv("R_HOME")
# Shows in order the paths which R searches to find the libraries
.libPaths()
# Shows in order the paths which R searches to find the libraries
.libPaths()
# Shows in order the paths which R searches to find the libraries
.libPaths()
# Shows in order the paths which R searches to find the libraries
.libPaths()
# Shows in order the paths which R searches to find the libraries
.libPaths()
.libPaths()
library(xlsx) # read xls -- Note that, xlsx packages depends on rJava and xlsxjars R packages.
library(rJava)
library(rJava)
library(xlsxjars)
library(xlsx) # read xls -- Note that, xlsx packages depends on rJava and xlsxjars R packages.
system("java -version")
remove.packages(rJava)
remove.packages("rJava")
library(xlsx) # read xls -- Note that, xlsx packages depends on rJava and xlsxjars R packages.
install.packages("rJava")
library(xlsx) # read xls -- Note that, xlsx packages depends on rJava and xlsxjars R packages.
?read.csv
# folder you want to scan (the scrip scans also the sub-folders)
path_dest <- ("D:/Desktop/SSD_GIS/Flood_Map")
# Set WD automatically
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# Check the wd
getwd()
### READ EXCEL ----
# see if in the directory I want to scan there is an excel file with the general informations for the report
exist <- which(list.files() == "metadata_to_fill.xlsx")
### READ EXCEL ----
# see if in the directory I want to scan there is an excel file with the general informations for the report
exist <- which(list.files() == "metadata_to_fill.csv")
df <- read.csv(paste(path,"/metadata_to_fill.csv", sep=""), header=FALSE, encoding="UTF-8")
# if the excel file is not available fills the relative information with "not available data"
if (!length(exist) == 0){
df <- read.csv(paste(path_dest,"/metadata_to_fill.csv", sep=""), header=FALSE, encoding="UTF-8")
} else {
df <- data.frame(stringsAsFactors=FALSE)
df[1,1] <- "Auteur(s): "
df[1,2] <- "not available "
# geometry
df[2,1] <- "Date: "
df[2,2] <- "not available "
# driver
df[3,1] <- "Localisation: "
df[3,2] <- "not available "
# crs
df[4,1] <- "ProblÃ¨mes:  "
df[4,2] <- "not available "
# feature count
df[5,1] <- "Commentaires "
df[5,2] <- "not available "
}
# if the excel file is not available fills the relative information with "not available data"
if (!length(exist) == 0){
df <- read.csv(paste(path_dest,"/metadata_to_fill.csv", sep=""), header=FALSE, encoding="UTF-8")
} else {
df <- data.frame(stringsAsFactors=FALSE)
df[1,1] <- "Auteur(s): "
df[1,2] <- "not available "
# geometry
df[2,1] <- "Date: "
df[2,2] <- "not available "
# driver
df[3,1] <- "Localisation: "
df[3,2] <- "not available "
# crs
df[4,1] <- "ProblÃ¨mes:  "
df[4,2] <- "not available "
# feature count
df[5,1] <- "Commentaires "
df[5,2] <- "not available "
}
paste(path_dest,"/metadata_to_fill.csv", sep="")
exist <- which(list.files() == "metadata_to_fill.csv")
### READ EXCEL ----
# see if in the directory I want to scan there is an excel file with the general informations for the report
exist <- which(list.files(path_dest) == "metadata_to_fill.csv")
# if the excel file is not available fills the relative information with "not available data"
if (!length(exist) == 0){
df <- read.csv(paste("path_dest","/metadata_to_fill.csv", sep=""), header=FALSE, encoding="UTF-8")
} else {
df <- data.frame(stringsAsFactors=FALSE)
df[1,1] <- "Auteur(s): "
df[1,2] <- "not available "
# geometry
df[2,1] <- "Date: "
df[2,2] <- "not available "
# driver
df[3,1] <- "Localisation: "
df[3,2] <- "not available "
# crs
df[4,1] <- "ProblÃ¨mes:  "
df[4,2] <- "not available "
# feature count
df[5,1] <- "Commentaires "
df[5,2] <- "not available "
}
### READ EXCEL ----
# see if in the directory I want to scan there is an excel file with the general informations for the report
exist <- which(list.files(path_dest) == "metadata_to_fill.csv")
### READ EXCEL ----
# see if in the directory I want to scan there is an excel file with the general informations for the report
exist <- which(list.files(path_dest) == "metadata_to_fill.csv")
?read.csv
df
# if the excel file is not available fills the relative information with "not available data"
if (!length(exist) == 0){
df <- read.csv(paste("path_dest","/metadata_to_fill.csv", sep=""), header=FALSE, encoding="Latin-1")
} else {
df <- data.frame(stringsAsFactors=FALSE)
df[1,1] <- "Auteur(s): "
df[1,2] <- "not available "
# geometry
df[2,1] <- "Date: "
df[2,2] <- "not available "
# driver
df[3,1] <- "Localisation: "
df[3,2] <- "not available "
# crs
df[4,1] <- "ProblÃ¨mes:  "
df[4,2] <- "not available "
# feature count
df[5,1] <- "Commentaires "
df[5,2] <- "not available "
}
df
# if the excel file is not available fills the relative information with "not available data"
if (!length(exist) == 0){
df <- read.csv(paste("path_dest","/metadata_to_fill.csv", sep=""), header=FALSE, encoding="Latin-1")
} else {
df <- data.frame(stringsAsFactors=FALSE)
df[1,1] <- "Auteur(s): "
df[1,2] <- "not available "
# geometry
df[2,1] <- "Date: "
df[2,2] <- "not available "
# driver
df[3,1] <- "Localisation: "
df[3,2] <- "not available "
# crs
df[4,1] <- "ProblÃ¨mes:  "
df[4,2] <- "not available "
# feature count
df[5,1] <- "Commentaires "
df[5,2] <- "not available "
}
read.csv(paste("path_dest","/metadata_to_fill.csv", sep=""), header=FALSE, encoding="Latin-1")
# if the excel file is not available fills the relative information with "not available data"
if (!length(exist) == 0){
df <- read.csv(paste(path_dest,"/metadata_to_fill.csv", sep=""), header=FALSE, encoding="Latin-1")
} else {
df <- data.frame(stringsAsFactors=FALSE)
df[1,1] <- "Auteur(s): "
df[1,2] <- "not available "
# geometry
df[2,1] <- "Date: "
df[2,2] <- "not available "
# driver
df[3,1] <- "Localisation: "
df[3,2] <- "not available "
# crs
df[4,1] <- "ProblÃ¨mes:  "
df[4,2] <- "not available "
# feature count
df[5,1] <- "Commentaires "
df[5,2] <- "not available "
}
rm(df)
# if the excel file is not available fills the relative information with "not available data"
if (!length(exist) == 0){
df <- read.csv(paste(path_dest,"/metadata_to_fill.csv", sep=""), header=FALSE, encoding="Latin-1")
} else {
df <- data.frame(stringsAsFactors=FALSE)
df[1,1] <- "Auteur(s): "
df[1,2] <- "not available "
# geometry
df[2,1] <- "Date: "
df[2,2] <- "not available "
# driver
df[3,1] <- "Localisation: "
df[3,2] <- "not available "
# crs
df[4,1] <- "ProblÃ¨mes:  "
df[4,2] <- "not available "
# feature count
df[5,1] <- "Commentaires "
df[5,2] <- "not available "
}
View(df)
View(df)
rm(df)
# if the excel file is not available fills the relative information with "not available data"
if (!length(exist) == 0){
df <- read.csv(paste(path_dest,"/metadata_to_fill.csv", sep=""), header=FALSE, encoding="Latin-1")
} else {
df <- data.frame(stringsAsFactors=FALSE)
df[1,1] <- "Auteur(s): "
df[1,2] <- "not available "
# geometry
df[2,1] <- "Date: "
df[2,2] <- "not available "
# driver
df[3,1] <- "Localisation: "
df[3,2] <- "not available "
# crs
df[4,1] <- "ProblÃ¨mes:  "
df[4,2] <- "not available "
# feature count
df[5,1] <- "Commentaires "
df[5,2] <- "not available "
}
View(df)
rm(df)
# if the excel file is not available fills the relative information with "not available data"
if (!length(exist) == 0){
df <- read.csv(paste(path_dest,"/metadata_to_fill.csv", sep=""), header=FALSE, encoding="UTF-8")
} else {
df <- data.frame(stringsAsFactors=FALSE)
df[1,1] <- "Auteur(s): "
df[1,2] <- "not available "
# geometry
df[2,1] <- "Date: "
df[2,2] <- "not available "
# driver
df[3,1] <- "Localisation: "
df[3,2] <- "not available "
# crs
df[4,1] <- "ProblÃ¨mes:  "
df[4,2] <- "not available "
# feature count
df[5,1] <- "Commentaires "
df[5,2] <- "not available "
}
View(df)
View(df)
# if the excel file is not available fills the relative information with "not available data"
if (!length(exist) == 0){
df <- read.csv(paste(path_dest,"/metadata_to_fill.csv", sep=""), header=FALSE, encoding="Latin-1")
} else {
df <- data.frame(stringsAsFactors=FALSE)
df[1,1] <- "Auteur(s): "
df[1,2] <- "not available "
# geometry
df[2,1] <- "Date: "
df[2,2] <- "not available "
# driver
df[3,1] <- "Localisation: "
df[3,2] <- "not available "
# crs
df[4,1] <- "Problèmes:  "
df[4,2] <- "not available "
# feature count
df[5,1] <- "Commentaires "
df[5,2] <- "not available "
}
list_shp <- list.files(path = path_dest, pattern = ".*shp$", recursive = TRUE) # gets all the shapefile in the folder
list.files(path = path_dest, pattern = ".*shp$", recursive = TRUE) # gets all the shapefile in the folder
list_whaaat <- list()
list_whaaat <- list()
# this is the DF that hosts all the metadata information
tabellone <- data.frame(stringsAsFactors=FALSE)
# this is the list of all the "tabellone" dataframes belonging to each shapefile
list_tabellone <- list()
st_read(paste("./",list_shp[i],sep = "")
)
library(sf) # manipulate shp
st_read(paste("./",list_shp[i],sep = ""))
for (i in 1:length(list_shp)){
# read shapefile with sf package
att_table <- st_read(paste("./",list_shp[i],sep = ""))
att_layers <- st_layers(paste("./",list_shp[i],sep = ""))
# get the attribute table compiled
# name
tabellone[1,1] <- "Name "
tabellone[1,2] <- att_layers$name
# geometry
tabellone[2,1] <- "Geometry "
tabellone[2,2] <- att_layers$geomtype[[1]]
# driver
tabellone[3,1] <- "Driver "
tabellone[3,2] <- att_layers$driver
# crs
tabellone[4,1] <- "CRS  "
tabellone[4,2] <- st_crs(att_table)[1]
tabellone[5,1] <- ""
tabellone[5,2] <- st_crs(att_table)[2]
# feature count
tabellone[6,1] <- "Feature count "
tabellone[6,2] <- att_layers$features
# fields count
tabellone[7,1] <- "Fields count "
tabellone[7,2] <- att_layers$fields
list_tabellone[[i]] <- tabellone
# read shapefile with shapefile package
temp_shp <- strsplit(list_shp[i], split='.shp', fixed=TRUE)
shape <- read.dbf(paste(temp_shp,".dbf",sep = ""), header = TRUE)
list_whaaat[[i]] <- shape$header$fields
}
st_read(".","Awerial")
st_layers(".","Awerial")
att_table <- st_read(".","Awerial")
att_layers <- st_layers(".","Awerial")
att_layers
att_layers$name
?st_read
att_layers$geomtype[[1]]
att_layers$driver
st_crs(att_table)[1]
st_crs(att_table)[2]
att_layers$features
att_layers$fields
library(shapefiles) # library used to get the attr table
install.packages("shapefile")
install.packages('D:/Downloads/shapefiles_0.7.zip', repos = NULL, type = "win.binary")
library(shapefiles) # library used to get the attr table
list_shp <- list.files(path = path_dest, pattern = ".*shp$", recursive = TRUE) # gets all the shapefile in the folder
list_whaaat <- list()
# this is the DF that hosts all the metadata information
tabellone <- data.frame(stringsAsFactors=FALSE)
# this is the list of all the "tabellone" dataframes belonging to each shapefile
list_tabellone <- list()
for (i in 1:length(list_shp)){
# read shapefile with sf package
att_table <- st_read(paste("./",list_shp[i],sep = ""))
att_layers <- st_layers(paste("./",list_shp[i],sep = ""))
# get the attribute table compiled
# name
tabellone[1,1] <- "Name "
tabellone[1,2] <- att_layers$name
# geometry
tabellone[2,1] <- "Geometry "
tabellone[2,2] <- att_layers$geomtype[[1]]
# driver
tabellone[3,1] <- "Driver "
tabellone[3,2] <- att_layers$driver
# crs
tabellone[4,1] <- "CRS  "
tabellone[4,2] <- st_crs(att_table)[1]
tabellone[5,1] <- ""
tabellone[5,2] <- st_crs(att_table)[2]
# feature count
tabellone[6,1] <- "Feature count "
tabellone[6,2] <- att_layers$features
# fields count
tabellone[7,1] <- "Fields count "
tabellone[7,2] <- att_layers$fields
list_tabellone[[i]] <- tabellone
# read shapefile with shapefile package
temp_shp <- strsplit(list_shp[i], split='.shp', fixed=TRUE)
shape <- read.dbf(paste(temp_shp,".dbf",sep = ""), header = TRUE)
list_whaaat[[i]] <- shape$header$fields
}
for (i in 1:length(list_shp)){
# read shapefile with sf package
att_table <- st_read(paste(path_dest,list_shp[i],sep = ""))
att_layers <- st_layers(paste(path_dest,list_shp[i],sep = ""))
# get the attribute table compiled
# name
tabellone[1,1] <- "Name "
tabellone[1,2] <- att_layers$name
# geometry
tabellone[2,1] <- "Geometry "
tabellone[2,2] <- att_layers$geomtype[[1]]
# driver
tabellone[3,1] <- "Driver "
tabellone[3,2] <- att_layers$driver
# crs
tabellone[4,1] <- "CRS  "
tabellone[4,2] <- st_crs(att_table)[1]
tabellone[5,1] <- ""
tabellone[5,2] <- st_crs(att_table)[2]
# feature count
tabellone[6,1] <- "Feature count "
tabellone[6,2] <- att_layers$features
# fields count
tabellone[7,1] <- "Fields count "
tabellone[7,2] <- att_layers$fields
list_tabellone[[i]] <- tabellone
# read shapefile with shapefile package
temp_shp <- strsplit(list_shp[i], split='.shp', fixed=TRUE)
shape <- read.dbf(paste(temp_shp,".dbf",sep = ""), header = TRUE)
list_whaaat[[i]] <- shape$header$fields
}
for (i in 1:length(list_shp)){
# read shapefile with sf package
att_table <- st_read(paste(path_dest,"/",list_shp[i],sep = ""))
att_layers <- st_layers(paste(path_dest,"/",list_shp[i],sep = ""))
# get the attribute table compiled
# name
tabellone[1,1] <- "Name "
tabellone[1,2] <- att_layers$name
# geometry
tabellone[2,1] <- "Geometry "
tabellone[2,2] <- att_layers$geomtype[[1]]
# driver
tabellone[3,1] <- "Driver "
tabellone[3,2] <- att_layers$driver
# crs
tabellone[4,1] <- "CRS  "
tabellone[4,2] <- st_crs(att_table)[1]
tabellone[5,1] <- ""
tabellone[5,2] <- st_crs(att_table)[2]
# feature count
tabellone[6,1] <- "Feature count "
tabellone[6,2] <- att_layers$features
# fields count
tabellone[7,1] <- "Fields count "
tabellone[7,2] <- att_layers$fields
list_tabellone[[i]] <- tabellone
# read shapefile with shapefile package
temp_shp <- strsplit(list_shp[i], split='.shp', fixed=TRUE)
shape <- read.dbf(paste(temp_shp,".dbf",sep = ""), header = TRUE)
list_whaaat[[i]] <- shape$header$fields
}
